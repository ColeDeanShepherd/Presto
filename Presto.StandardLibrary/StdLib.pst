##### All Types #####
no_op = fn (): nothing -> {}
ignore = fn [t] (x: t): nothing -> {}
identity = fn [t] (x: t): t -> x

eq = fn [t] (a: t, b: t): bool -> impl_in_CSharp[bool]()
not_eq = fn [t] (a: t, b: t): bool -> not(eq(a, b))

to_text = fn [t] (x: t): text -> impl_in_CSharp[text]()

##### Boolean #####
is_true = fn (x: bool): bool -> x == true
is_false = fn (x: bool): bool -> x == false
not = fn (x: bool): bool -> if x then false else true

# logical_and = fn (a: bool, b: bool): bool = BUILT_IN
# logical_or = fn (a: bool, b: bool): bool = BUILT_IN
# logical_xor = fn (a: bool, b: bool): bool = BUILT_IN
# logical_nand = fn (a: bool, b: bool): bool = BUILT_IN
# logical_nor = fn (a: bool, b: bool): bool = BUILT_IN
# logical_not = fn (a: bool, b: bool): bool = BUILT_IN
# logical_xnor = fn (a: bool, b: bool): bool = BUILT_IN

##### Natural Numbers & Reals #####
sum = fn (a: nat, b: nat): nat -> impl_in_CSharp[nat]()
difference = fn (a: nat, b: nat): nat -> impl_in_CSharp[nat]()
product = fn (a: nat, b: nat): nat -> impl_in_CSharp[nat]()
quotient = fn (a: nat, b: nat): nat -> impl_in_CSharp[nat]()
# modulus
# remainder
# power
# floor
# ceiling
# is_even
# is_odd
# is_divisble_by
# lcd
# gcd
# abs
# sin
# cos
# tan
# asin
# acos
# atan
# atan2
# sinh
# cosh
# tanh
# asinh
# acosh
# atanh
# clamp
# divrem
# exp
# log
# log2
# log10
# round
# sign
# sqrt
# truncate

##### Comparable #####
# min
# max

##### Char #####
# is_ascii
# is_digit
# is_alpha
# is_whitespace
# is_lower
# is_upper
# to_lower
# to_upper

##### String #####
length = fn (x: text): nat -> impl_in_CSharp[nat]()
concatenate = fn (a: text, b: text): text -> a + b
# contains
# starts_with
# ends_with
# first_index_of
# last_index_of
# pad_left
# pad_right
# insert
# remove
# replace
# split
uppercase = fn (x: text): text -> impl_in_CSharp[text]()
# to_lower
# trim
# trim_start
# trim_end
parse_real = fn (x: text): Result[real, text] -> impl_in_CSharp[Result[real, text]]()
get_lines = fn (x: seq[char]): seq[text] -> impl_in_CSharp[seq[text]]()
split_by = fn (x: text, separator: text): seq[text] -> impl_in_CSharp[seq[text]]()

##### List/Seq #####
# head
# tail
# last
list_1st = fn [t] (x: seq[t]): t -> impl_in_CSharp[t]()
list_2nd = fn [t] (x: seq[t]): t -> impl_in_CSharp[t]()
last_or_default = fn [t] (x: seq[t], default: t): t -> impl_in_CSharp[t]()

##### Tuple #####
_1st = fn [t1, t2] (x: (t1, t2)): t1 -> impl_in_CSharp[t1]()
_2nd = fn [t1, t2] (x: (t1, t2)): t2 -> impl_in_CSharp[t2]()
t4_1st = fn [t1, t2, t3, t4] (x: (t1, t2, t3, t4)): t1 -> impl_in_CSharp[t1]()
t4_2nd = fn [t1, t2, t3, t4] (x: (t1, t2, t3, t4)): t2 -> impl_in_CSharp[t2]()
t4_3rd = fn [t1, t2, t3, t4] (x: (t1, t2, t3, t4)): t3 -> impl_in_CSharp[t3]()
t4_4th = fn [t1, t2, t3, t4] (x: (t1, t2, t3, t4)): t4 -> impl_in_CSharp[t4]()

##### Grouping #####
key = fn [t, tkey] (x: Grouping[t, tkey]): tkey -> impl_in_CSharp[tkey]()
values = fn [t, tkey] (x: Grouping[t, tkey]): t -> impl_in_CSharp[t]()

##### Result #####
unwrap = fn [t, e] (x: Result[t, e]): t -> impl_in_CSharp[t]()

##### Higher-order Functions #####
map = fn [ti, to] (x: seq[ti], f: fn (x: ti): to): seq[to] -> impl_in_CSharp[seq[to]]()
sort_by = fn [t, ts] (x: seq[t], f: fn (x: t): ts): seq[t] -> impl_in_CSharp[seq[t]]()
group_by = fn [t, tkey] (x: seq[t], f: fn (x: t): tkey): Grouping[t, tkey] -> impl_in_CSharp[Grouping[t, tkey]]()

##### Console #####
read_real = fn (console: Console): Result[real, text] -> impl_in_CSharp[Result[real, text]]()
read_line = fn (console: Console): Result[text, text] -> impl_in_CSharp[Result[text, text]]()

print = fn (console: Console): Result[nothing, text] -> impl_in_CSharp[Result[nothing, text]]()
print_line = fn (console: Console): Result[nothing, text] -> impl_in_CSharp[Result[nothing, text]]()

##### File System #####
read_text_file = fn (file_system: FileSystem, file_path: text): seq[char] -> impl_in_CSharp[seq[char]]()