no_op = fn (): nothing -> {}
ignore = fn [t] (x: t): nothing -> {}
identity = fn [t] (x: t): t -> x

# eq = fn [t] (a: t, b: t): bool -> BUILT_IN
not_eq = fn [t] (a: t, b: t): bool -> not(eq(a, b))

##### Boolean #####
is_true = fn (x: bool): bool -> x == true
is_false = fn (x: bool): bool -> x == false
not = fn (x: bool): bool -> if x then false else true

# logical_and = fn (a: bool, b: bool): bool = BUILT_IN
# logical_or = fn (a: bool, b: bool): bool = BUILT_IN
# logical_xor = fn (a: bool, b: bool): bool = BUILT_IN
# logical_nand = fn (a: bool, b: bool): bool = BUILT_IN
# logical_nor = fn (a: bool, b: bool): bool = BUILT_IN
# logical_not = fn (a: bool, b: bool): bool = BUILT_IN
# logical_xnor = fn (a: bool, b: bool): bool = BUILT_IN

##### Arithmetic #####
# add
# subtract
# multiply
# divide
# modulus
# remainder
# power
# floor
# ceiling
# is_even
# is_odd
# is_divisble_by
# lcd
# gcd
# abs
# sin
# cos
# tan
# asin
# acos
# atan
# atan2
# sinh
# cosh
# tanh
# asinh
# acosh
# atanh
# clamp
# divrem
# exp
# log
# log2
# log10
# round
# sign
# sqrt
# truncate

##### Comparable #####
# min
# max

##### Char #####
# is_ascii
# is_digit
# is_alpha
# is_whitespace
# is_lower
# is_upper
# to_lower
# to_upper

##### String #####
# length
concatenate = fn (a: text, b: text): text -> a + b
# contains
# starts_with
# ends_with
# first_index_of
# last_index_of
# pad_left
# pad_right
# insert
# remove
# replace
# split
# to_upper
# to_lower
# trim
# trim_start
# trim_end

##### List #####
# head
# tail
# last